{
  "file_path": "src/reduce.cpp, src/reduce.h, src/solver.cpp",
  "function_name": "Reduce class, GCP::Reduce, Solver::solve_gcp_gurobi",
  "code_snippet": "\n\n# ==========================================\n# File: src/reduce.cpp\n# Function/Context: Reduce class\n# ==========================================\n#include \"reduce.h\"\n#include <cmath>\n#include <limits>\n\nnamespace GCP {\n    Reduce::Reduce(const Instance& g) : g{g} {\n        initializing_parameters();\n    }\n\n    void Reduce::initializing_parameters(){\n        num_thread = omp_get_max_threads();\n        cout << \"threads used: \" << num_thread << endl;\n        num_mis = mis_factor * g.size();\n        cout << \"number of MISs generated is \" <<num_mis << endl;\n        mis_sets.resize(num_mis);\n        adj_list = g.get_adj_list();\n        adj_matrix = vector<vector<bool>>(g.size(), vector<bool>(g.size(), 0));\n        for (int i = 0; i < g.size(); ++i){\n            for (int j = 0; j < adj_list[i].size(); ++j){\n                adj_matrix[i][adj_list[i][j]] = 1;\n                adj_matrix[adj_list[i][j]][i] = 1;\n            }\n        }\n        sample_size = num_mis * sample_factor;\n        cout << \"sample size is \" << sample_size << endl;\n        samples.resize(sample_size);\n        objs = vector<int>(sample_size, 0);\n        rank = vector<int>(sample_size);\n        vertex_mis_mapping.resize(g.size());\n\n        set_size = vector<int>(num_mis);\n        max_set_degree = vector<float>(num_mis);\n        ave_set_degree = vector<float>(num_mis);\n        min_set_degree = vector<float>(num_mis);\n        std_set_degree = vector<float>(num_mis);\n        max_rel_set_size = vector<float>(num_mis);\n        ave_rel_set_size = vector<float>(num_mis);\n        min_rel_set_size = vector<float>(num_mis);\n        std_rel_set_size = vector<float>(num_mis);\n        vertex_max_mis_size = vector<int>(g.size(), 0);\n        best_obj_sampling = g.size();\n\n        ranking_scores = vector<float>(num_mis);\n        corr_xr = vector<float>(num_mis);\n        objective_scores = vector<float>(num_mis);\n        corr_xy = vector<float>(num_mis);\n        ml_score = vector<float>(num_mis);\n        predicted_value = vector<bool>(num_mis);\n        mis_sorted = vector<bool>(num_mis, 0);\n        lp_solution.resize(num_mis);\n        reduced_cost.resize(num_mis);\n    }\n\n    void Reduce::initializing_mis() {\n        #pragma omp parallel\n        {\n            int threadnum = omp_get_thread_num();\n            int low = num_mis * threadnum / num_thread;\n            int high = num_mis * (threadnum+1) / num_thread;\n            random_device rd;\n            mt19937 gen(rd() + threadnum);\n            srand (time(NULL) + threadnum);\n            int v, idx, num;\n            vector<int> candidates(g.size());\n            int nb_candidates;\n            for(int i = low; i < high; ++i) {\n                nb_candidates = g.size();\n                for (int j = 0; j < nb_candidates; ++j){\n                    candidates[j] = j;\n                }\n                while (nb_candidates > 0){\n                    if (nb_candidates == g.size()){\n                        idx = i % g.size();\n                    } else{\n                        idx = rand() % nb_candidates;\n                    }\n                    v = candidates[idx];\n                    mis_sets[i].push_back(v);\n                    num = 0;\n                    for (int j = 0; j < nb_candidates; ++j){\n                        if (adj_matrix[v][candidates[j]] == 0 && j != idx){\n                            candidates[num] = candidates[j];\n                            num++;\n                        }\n                    }\n                    nb_candidates = num;\n                }\n            }\n        }\n    }\n\n    void Reduce::computing_graph_features() {\n        for (int i = 0; i < num_mis; ++i){\n            max_set_degree[i] = 0.0;\n            ave_set_degree[i] = 0.0;\n            min_set_degree[i] = 1.0;\n            std_set_degree[i] = 0.0;\n            max_rel_set_size[i] = 0.0;\n            ave_rel_set_size[i] = 0.0;\n            min_rel_set_size[i] = 1.0;\n            std_rel_set_size[i] = 0.0;\n        }\n\n        max_set_size = 0;\n        for (int i = 0; i < g.size(); ++i){\n            vertex_mis_mapping[i].clear();\n            vertex_max_mis_size[i] = 0;\n        }\n\n        int v;\n        for (int i = 0; i < num_mis; ++i){\n            set_size[i] = mis_sets[i].size();\n            if (max_set_size < set_size[i]){\n                max_set_size = set_size[i];\n            }\n            for (int j = 0; j < set_size[i]; ++j){\n                v = mis_sets[i][j];\n                vertex_mis_mapping[v].push_back(i);\n                if (vertex_max_mis_size[v] < set_size[i]){\n                    vertex_max_mis_size[v] = set_size[i];\n                }\n\n                ave_set_degree[i] += g.get_degree(v) / set_size[i];\n                if (max_set_degree[i] < g.get_degree(v)){\n                    max_set_degree[i] = g.get_degree(v);\n                }\n                if (min_set_degree[i] > g.get_degree(v)){\n                    min_set_degree[i] = g.get_degree(v);\n                }\n            }\n            for (int j = 0; j < set_size[i]; ++j){\n                v = mis_sets[i][j];\n                std_set_degree[i] += pow(g.get_degree(v) - ave_set_degree[i], 2) / set_size[i];\n            }\n            std_set_degree[i] = sqrt(std_set_degree[i]);\n        }\n\n        double relative_size;\n        for (int i = 0; i < num_mis; ++i){\n            for (int j = 0; j < set_size[i]; ++j){\n                v = mis_sets[i][j];\n                relative_size = (double) set_size[i] / vertex_max_mis_size[v];\n                ave_rel_set_size[i] += relative_size / set_size[i];\n                if (max_rel_set_size[i] < relative_size){\n                    max_rel_set_size[i] = relative_size;\n                }\n                if (min_rel_set_size[i] > relative_size){\n                    min_rel_set_size[i] = relative_size;\n                }\n            }\n            for (int j = 0; j < set_size[i]; ++j){\n                v = mis_sets[i][j];\n                relative_size = (double) set_size[i] / vertex_max_mis_size[v];\n                std_rel_set_size[i] += pow(relative_size - ave_rel_set_size[i], 2) / set_size[i];\n            }\n            std_rel_set_size[i] = sqrt(std_rel_set_size[i]);\n        }\n    }\n\n    void Reduce::multi_thread_sampling() {\n        #pragma omp parallel\n        {\n            int threadnum = omp_get_thread_num();\n            int low = sample_size * threadnum / num_thread;\n            int high = sample_size * (threadnum+1) / num_thread;\n            random_device rd;\n            mt19937 gen(rd() + threadnum);\n            srand (time(NULL) + threadnum);\n            vector<bool> covered_vertex(g.size());\n            vector<int> vertices(g.size());\n            iota(vertices.begin(), vertices.end(), 0);\n            int v, idx, s;\n            for(int i = low; i < high; ++i) {\n                samples[i].clear();\n                shuffle(vertices.begin(), vertices.end(), gen);\n                for (int j = 0; j < g.size(); ++j){\n                    covered_vertex[j] = 0;\n                }\n                for (int j = 0; j < g.size(); ++j){\n                    v = vertices[j];\n                    if (covered_vertex[v] == 0){\n                        idx = rand() % vertex_mis_mapping[v].size();\n                        s = vertex_mis_mapping[v][idx];\n                        samples[i].push_back(s);\n                        for (int k = 0; k < mis_sets[s].size(); ++k){\n                            covered_vertex[mis_sets[s][k]] = 1;\n                        }\n                    }\n                }\n                objs[i] = samples[i].size();\n            }\n        }\n    }\n\n    void Reduce::compute_objective_rankings(){\n        vector<int> sort_idx(sample_size);\n        iota(sort_idx.begin(), sort_idx.end(), 0);\n        vector<int> objs_copy(objs);\n        sort(sort_idx.begin(), sort_idx.end(), [&objs_copy](int i1, int i2) {return objs_copy[i1] < objs_copy[i2];});\n        for (int i = 0; i < sample_size; ++i){\n            rank[sort_idx[i]] = i+1;\n        }\n\n        best_sol_sampling.clear();\n        best_sol_sampling = samples[sort_idx[0]];\n        best_obj_sampling = objs[sort_idx[0]];\n\n        cout << \"best obj in sampling is \" << best_obj_sampling << endl;\n    }\n\n    void Reduce::removing_variables_rbm() {\n        cout << \"problem reduction using ranking-based measure with threshold \" << threshold_r << endl;\n        compute_ranking_based_measure();\n        predicted_value = vector<bool>(num_mis, 0);\n        for (int i = 0; i < num_mis; ++i){\n            if (ranking_scores[i] > threshold_r){\n                predicted_value[i] = 1;\n            } else{\n                predicted_value[i] = 0;\n            }\n        }\n        repair();\n        compute_reduced_problem_size();\n    }\n\n    void Reduce::compute_ranking_based_measure() {\n        for (int i = 0; i < num_mis; ++i){\n            ranking_scores[i] = 0.0;\n        }\n        #pragma omp parallel\n        {\n            vector<float> ranking_scores_local = vector<float>(num_mis, 0.0);\n            int threadnum = omp_get_thread_num();\n            int low = sample_size * threadnum / num_thread;\n            int high = sample_size * (threadnum+1) / num_thread;\n            int s;\n            for (int i = low; i < high; ++i){\n                for (int j = 0; j < samples[i].size(); ++j){\n                    s = samples[i][j];\n                    ranking_scores_local[s] += 1.0/rank[i];\n                }\n            }\n            #pragma omp critical\n            for (int i = 0; i < num_mis; ++i){\n                ranking_scores[i] += ranking_scores_local[i];\n            }\n        }\n        max_rbm = 0.0;\n        for (int i = 0; i < num_mis; ++i){\n            if (ranking_scores[i] > max_rbm){\n                max_rbm = ranking_scores[i];\n            }\n        }\n    }\n\n    void Reduce::removing_variables_rcm(){\n        compute_rank_correlation_measure();\n        predicted_value = vector<bool>(num_mis, 0);\n        for (int i = 0; i < num_mis; ++i){\n            if (corr_xr[i] < threshold_c){\n                predicted_value[i] = 1;\n            } else{\n                predicted_value[i] = 0;\n            }\n        }\n        repair();\n        compute_reduced_problem_size();\n    }\n\n    void Reduce::compute_rank_correlation_measure(){\n        double mean_y = 0.0;\n        for (int i = 0; i < sample_size; ++i){\n            mean_y += (double)rank[i]/sample_size;\n        }\n        vector<double> diff_y(sample_size);\n        double variance_y = 0.0, sum_diff_y = 0.0;\n        for (int i = 0; i < sample_size; ++i){\n            diff_y[i] = (double)rank[i] - mean_y;\n            variance_y += diff_y[i]*diff_y[i];\n            sum_diff_y += diff_y[i];\n        }\n\n        vector<double> mean_x = vector<double>(num_mis, 0.0);\n        vector<double> S1 = vector<double>(num_mis, 0.0);\n\n        #pragma omp parallel\n        {\n            vector<double> mean_x_local = vector<double>(num_mis, 0.0);\n            vector<double> S1_local = vector<double>(num_mis, 0.0);\n            int threadnum = omp_get_thread_num();\n            int low = sample_size * threadnum / num_thread;\n            int high = sample_size * (threadnum+1) / num_thread;\n            double ratio = 1.0/sample_size;\n            int s;\n            for (int i = low; i < high; ++i){\n                for (int j = 0; j < samples[i].size(); ++j){\n                    s = samples[i][j];\n                    mean_x_local[s] += ratio;\n                    S1_local[s] += diff_y[i];\n                }\n            }\n            #pragma omp critical\n            for (int i = 0; i < num_mis; ++i){\n                mean_x[i] += mean_x_local[i];\n                S1[i] += S1_local[i];\n            }\n        }\n\n        vector<double> variance_x(num_mis, 0.0);\n        vector<double> variance_xy(num_mis, 0.0);\n\n        min_rcm = 1.0;\n        for (int i = 0; i < num_mis; ++i){\n            variance_x[i] = mean_x[i]*(1-mean_x[i])*sample_size;\n            variance_xy[i] = (1-mean_x[i])*S1[i] - mean_x[i]*(sum_diff_y - S1[i]);\n            if (variance_x[i] > 0){\n                corr_xr[i] = variance_xy[i]/sqrt(variance_x[i]*variance_y);\n            }else if (mean_x[i] == 0) {\n                corr_xr[i] = 1.0;\n            } else{\n                corr_xr[i] = - 1.0;\n            }\n            if (corr_xr[i] < min_rcm){\n                min_rcm = corr_xr[i];\n            }\n        }\n    }\n\n    void Reduce::removing_variables_obm(){\n        cout << \"problem reduction using objective-based measure with threshold \" << threshold_o << endl;\n        compute_objective_based_measure();\n        predicted_value = vector<bool>(num_mis, 0);\n        for (int i = 0; i < num_mis; ++i){\n            if (objective_scores[i] > threshold_o){\n                predicted_value[i] = 1;\n            } else{\n                predicted_value[i] = 0;\n            }\n        }\n        repair();\n        compute_reduced_problem_size();\n    }\n\n    void Reduce::compute_objective_based_measure() {\n        for (int i = 0; i < num_mis; ++i){\n            objective_scores[i] = 0.0;\n        }\n        #pragma omp parallel\n        {\n            vector<float> objective_scores_local = vector<float>(num_mis, 0.0);\n            int threadnum = omp_get_thread_num();\n            int low = sample_size * threadnum / num_thread;\n            int high = sample_size * (threadnum+1) / num_thread;\n            int s;\n            for (int i = low; i < high; ++i){\n                for (int j = 0; j < samples[i].size(); ++j){\n                    s = samples[i][j];\n                    objective_scores_local[s] += 1.0/(objs[i]);\n                }\n            }\n            #pragma omp critical\n            for (int i = 0; i < num_mis; ++i){\n                objective_scores[i] += objective_scores_local[i];\n            }\n        }\n        max_obm = 0.0;\n        for (int i = 0; i < num_mis; ++i){\n            if (objective_scores[i] > max_obm){\n                max_obm = objective_scores[i];\n            }\n        }\n    }\n\n    void Reduce::removing_variables_cbm(){\n        cout << \"problem reduction using correlation-based measure with threshold \" << threshold_c << endl;\n        compute_correlation_based_measure();\n        predicted_value = vector<bool>(num_mis, 0);\n        for (int i = 0; i < num_mis; ++i){\n            if (corr_xy[i] < threshold_c){\n                predicted_value[i] = 1;\n            } else{\n                predicted_value[i] = 0;\n            }\n        }\n        repair();\n        compute_reduced_problem_size();\n    }\n\n    void Reduce::compute_correlation_based_measure(){\n        double mean_y = 0.0;\n        for (int i = 0; i < sample_size; ++i){\n            mean_y += (double)objs[i]/sample_size;\n        }\n        vector<double> diff_y(sample_size);\n        double variance_y = 0.0, sum_diff_y = 0.0;\n        for (int i = 0; i < sample_size; ++i){\n            diff_y[i] = (double)objs[i] - mean_y;\n            variance_y += diff_y[i]*diff_y[i];\n            sum_diff_y += diff_y[i];\n        }\n\n        vector<double> mean_x = vector<double>(num_mis, 0.0);\n        vector<double> S1 = vector<double>(num_mis, 0.0);\n\n        #pragma omp parallel\n        {\n            vector<double> mean_x_local = vector<double>(num_mis, 0.0);\n            vector<double> S1_local = vector<double>(num_mis, 0.0);\n            int threadnum = omp_get_thread_num();\n            int low = sample_size * threadnum / num_thread;\n            int high = sample_size * (threadnum+1) / num_thread;\n            double ratio = 1.0/sample_size;\n            int s;\n            for (int i = low; i < high; ++i){\n                for (int j = 0; j < samples[i].size(); ++j){\n                    s = samples[i][j];\n                    mean_x_local[s] += ratio;\n                    S1_local[s] += diff_y[i];\n                }\n            }\n            #pragma omp critical\n            for (int i = 0; i < num_mis; ++i){\n                mean_x[i] += mean_x_local[i];\n                S1[i] += S1_local[i];\n            }\n        }\n\n        vector<double> variance_x(num_mis, 0.0);\n        vector<double> variance_xy(num_mis, 0.0);\n\n        min_cbm = 1.0;\n        for (int i = 0; i < num_mis; ++i){\n            variance_x[i] = mean_x[i]*(1-mean_x[i])*sample_size;\n            variance_xy[i] = (1-mean_x[i])*S1[i] - mean_x[i]*(sum_diff_y - S1[i]);\n            if (variance_x[i] > 0){\n                corr_xy[i] = variance_xy[i]/sqrt(variance_x[i]*variance_y);\n            }else if (mean_x[i] == 0) {\n                corr_xy[i] = 1.0;\n            } else{\n                corr_xy[i] = - 1.0;\n            }\n            if (corr_xy[i] < min_cbm){\n                min_cbm = corr_xy[i];\n            }\n        }\n    }\n}\n\n# ==========================================\n# File: src/reduce.h\n# Function/Context: GCP::Reduce\n# ==========================================\n#ifndef REDUCE_H\n#define REDUCE_H\n#include \"instance.h\"\n#include \"decision_tree.h\"\n\nextern \"C\" {\n#include \"svm_predict_model.h\"\n#include \"linear_svm_predict_model.h\"\n}\n\n#include <random>\n#include <algorithm>\n#include <iterator>\n#include <iostream>\n#include <numeric>      // std::iota\n#include <vector>\n#include <cstring>\n#include <string>\n#include <time.h>\n#include <sys/time.h>\n#include <iomanip>\n#include <omp.h>\n#include \"gurobi_c++.h\"\n\nusing namespace std;\n\nnamespace GCP{\n    class Reduce{\n        const Instance& g;\n        const float threshold_r = 0.05;\n        const float threshold_o = 1;\n        const float threshold_c = 0;\n        const float threshold_ml = 0.2;\n        const string test_data_dir = \"../test_data/\";\n        const string training_data_dir = \"../train_data/\";\n        const string training_model_name = \"train_model\";\n        const string test_data_name = \"_test_data_\";\n        const string output_file_name = \"_predicted_value_\";\n        const int sample_factor = 1;\n        const int mis_factor = 20;\n        const int iterations = 10;\n        const float prop = 0.5;\n        int num_mis = 0;\n        int sample_size = 0;\n        int probability = 0;\n        int num_thread = 0;\n        double lp_bound = 0.0;\n        vector<int> mis_sets_left;\n        vector<vector<int>> samples;\n        vector<vector<int>> mis_sets;\n        vector<vector<int>> selected_mis_sets;\n        vector<vector<int>> adj_list;\n        vector<vector<bool>> adj_matrix;\n        vector<vector<int>> vertex_mis_mapping;\n        vector<int> objs;\n        int best_obj_sampling;\n        vector<int> best_sol_sampling;\n        vector<int> rank;\n        vector<bool> predicted_value;\n        vector<bool> mis_sorted;\n        vector<float> ranking_scores;\n        vector<float> objective_scores;\n        vector<float> corr_xy;\n        vector<float> corr_xr;\n        vector<double> lp_solution;\n        vector<double> reduced_cost;\n        vector<int> set_size;\n        vector<float> max_set_degree;\n        vector<float> ave_set_degree;\n        vector<float> min_set_degree;\n        vector<float> std_set_degree;\n        vector<float> max_rel_set_size;\n        vector<float> ave_rel_set_size;\n        vector<float> min_rel_set_size;\n        vector<float> std_rel_set_size;\n        vector<int> vertex_max_mis_size;\n        vector<float> ml_score;\n        int max_set_size;\n        float min_cbm, min_rcm, max_rbm, max_obm;\n        int num_mis_selected = 0;\n        void multi_thread_sampling();\n        void compute_objective_rankings();\n        void constructing_test_data();\n        void loading_output_data();\n        void initializing_parameters();\n    public:\n        explicit Reduce(const Instance& g);\n        void initializing_mis();\n        void removing_variables_rbm();\n        void removing_variables_obm();\n        void removing_variables_cbm();\n        void removing_variables_rcm();\n        void removing_variables_svm();\n        void removing_variables_none();\n        void removing_variables_svm_linear();\n        void repair();\n        int get_objective_value_sampling() const { return best_obj_sampling; }\n        bool get_predicted_value(int i) const { return predicted_value[i]; }\n        int get_mis_sets_left(int i) const { return mis_sets_left[i]; }\n        float get_cbm_value(int i) const { return corr_xy[i]; }\n        float get_rcm_value(int i) const { return corr_xr[i]; }\n        float get_rbm_value(int i) const { return ranking_scores[i]; }\n        float get_obm_value(int i) const { return objective_scores[i]; }\n        double get_lp_solution(int i) const { return lp_solution[i]; }\n        float get_min_cbm() const { return min_cbm; }\n        float get_min_rcm() const { return min_rcm; }\n        float get_max_rbm() const { return max_rbm; }\n        float get_max_obm() const { return max_obm; }\n        void compute_reduced_problem_size();\n        void compute_correlation_based_measure();\n        void compute_ranking_based_measure();\n        void compute_rank_correlation_measure();\n        void compute_objective_based_measure();\n        void compute_lp_solution();\n        void computing_graph_features();\n        void evaluating_mis_linear_svm();\n        void evaluating_mis_decision_tree();\n        void ml_evolving_mis();\n        void updating_mis_random();\n        void updating_mis_crossover();\n        void selecting_high_quality_mis();\n        void compute_selected_mis_sets();\n        void removing_duplicates();\n        void solve_submip();\n        int get_num_mis_selected() const { return num_mis_selected; }\n        vector<int> get_best_sol_sampling() const { return best_sol_sampling; }\n        vector<vector<int>> get_selected_mis_sets() const {return selected_mis_sets; }\n    };\n}\n\n#endif\n\n# ==========================================\n# File: src/solver.cpp\n# Function/Context: Solver::solve_gcp_gurobi\n# ==========================================\n#include \"solver.h\"\n#include <cmath>\n#include <limits>\n////#include \"Timer.h\"\n//#include \"instance.h\"\n//#include <iostream>\n//#include <vector>\n//#include <omp.h>\n//#include \"gurobi_c++.h\"\n\nusing namespace std;\n\nnamespace GCP {\n    void Solver::solve_gcp_gurobi() {\n        int n = r.get_num_mis_selected();\n        int m = ins.size();\n        vector<vector<bool>> mis_sets_binary(n, vector<bool>(m, 0));\n        vector<vector<int>> mis_sets = r.get_selected_mis_sets();\n        int v;\n        for (int i = 0; i < n; ++i){\n//            cout << \"MIS  \" << i << \" : \";\n            for (int j = 0; j < mis_sets[i].size(); ++j){\n                v = mis_sets[i][j];\n                mis_sets_binary[i][v] = 1;\n//                cout << v << \", \" ;\n            }\n//            cout << endl;\n        }\n        cout << \"number of mis sets used is \" << n << endl;\n\n        // setup the model now\n        GRBEnv *env;\n        vector<GRBVar> x;\n        try {\n            env = new GRBEnv();\n            GRBModel model = GRBModel(*env);\n            model.getEnv().set(GRB_IntParam_OutputFlag, 1);\n            model.set(GRB_StringAttr_ModelName, \"MIP_GCP\");\n            // Create variables and set them to be binary\n            x.resize(n);\n            for (int i = 0; i < n; ++i){\n                x[i] = model.addVar(0,1,0,GRB_BINARY);\n            }\n            model.update();\n\n            // each vertex is covered by at least one set\n            for (int j = 0; j < m; ++j){\n                GRBLinExpr rtot = 0;\n                for (int i = 0; i < n; ++i){\n                    rtot += mis_sets_binary[i][j] * x[i];\n                }\n                model.addConstr(rtot >= 1, \"\");\n            }\n            model.update();\n\n            // set time limit\n            model.set(GRB_DoubleParam_TimeLimit, cutoff);\n            // set number of thread\n            model.set(GRB_IntParam_Threads, omp_get_max_threads());\n            // set random seed\n            srand (time(NULL));\n            model.set(GRB_IntParam_Seed, rand()%10000);\n\n            model.set(GRB_IntParam_Presolve, 1);\n//            model.set(GRB_IntParam_MIPFocus, 1);\n//            model.set(GRB_DoubleParam_ImproveStartNodes, 0.0);\n//            model.set(GRB_DoubleParam_ImproveStartTime, 0.0);\n\n            // the objective\n            GRBLinExpr tot=0;\n            for(int i = 0; i < n; ++i){\n                tot += x[i];\n            }\n            model.setObjective(tot,GRB_MINIMIZE);\n            model.update();\n            model.optimize();\n            objVal = model.get(GRB_DoubleAttr_ObjVal);\n            objBound = model.get(GRB_DoubleAttr_ObjBound);\n            opt_sol.resize((int) (objVal + 0.5));\n            int k = 0;\n            cout << \"optimal solution is : \" << endl;\n            for (int i = 0; i < n; ++i){\n                if (x[i].get(GRB_DoubleAttr_X) > 0.5){\n                    cout << \"color \" << k << \" : \" ;\n                    opt_sets.push_back(i);\n                    for (int j = 0; j < mis_sets[i].size(); ++j){\n                        opt_sol[k].push_back(mis_sets[i][j]);\n                        cout <<  mis_sets[i][j] << \", \" ;\n                    }\n                    cout << endl;\n                    k++;\n                }\n            }\n        }\n\n        catch(GRBException e) {\n            cout << \"Error code = \" << e.getErrorCode() << endl;\n            cout << e.getMessage() << endl;\n        }\n        catch(...) {\n            cout << \"Exception during optimization\" << endl;\n        }\n\n        delete env;\n    }\n}",
  "description": "Combined Analysis:\n- [src/reduce.cpp]: This file implements the core ML-based column selection mechanism for the Vertex Coloring Problem. It generates Maximal Independent Sets (MISs/columns), computes graph features, performs sampling to create training data, and implements four statistical measures (RBM, RCM, OBM, CBM) to predict which columns are likely to be in optimal solutions. These measures correspond to the ML model's scoring functions described in the paper. The code performs problem reduction by filtering columns based on threshold values, directly implementing the column selection step of the MLCG algorithm.\n- [src/reduce.h]: This header file implements the core column reduction logic of the MLCG method for Vertex Coloring. The Reduce class encapsulates the key algorithm steps: 1) It maintains MIS sets (columns) in 'mis_sets' and 'selected_mis_sets', 2) Implements multiple reduction strategies (RBM, OBM, CBM, RCM, SVM) for filtering columns, 3) Uses machine learning models (SVM and decision tree) to predict column quality via 'evaluating_mis_linear_svm()' and 'evaluating_mis_decision_tree()', 4) Computes LP solutions and reduced costs for columns, 5) Performs sampling and evolutionary operations ('updating_mis_random', 'updating_mis_crossover') to generate high-quality columns, 6) Solves sub-MIP problems via 'solve_submip()'. The class directly corresponds to the paper's ML-based column selection approach, where columns (MISs) are filtered using ML predictions and various measures before solving the restricted master problem.\n- [src/solver.cpp]: This file implements the core optimization model from the paper: the set covering formulation of the Vertex Coloring Problem as a Mixed-Integer Program (MIP). The function solve_gcp_gurobi() directly maps to the mathematical model: it creates binary variables x_S for each selected Maximal Independent Set (MIS), adds covering constraints requiring each vertex to be in at least one selected MIS, and minimizes the sum of x_S (number of colors used). This is the restricted master problem solved after ML-based column selection. The code uses Gurobi as the MIP solver and includes parameter settings for time limits, threads, and presolve.",
  "dependencies": [
    "iterator",
    "OpenMP (omp.h)",
    "string",
    "numeric",
    "Gurobi (for optimization solver)",
    "omp.h",
    "sys/time.h",
    "vector",
    "Standard C++ libraries (cmath, limits, random, algorithm, vector, iostream)",
    "instance.h",
    "algorithm",
    "decision_tree.h",
    "Gurobi C++ API (gurobi_c++.h)",
    "gurobi_c++.h",
    "iomanip",
    "Custom headers (solver.h)",
    "Custom headers: reduce.h, instance.h",
    "random",
    "igraph library (for graph operations)",
    "linear_svm_predict_model.h",
    "svm_predict_model.h",
    "Standard C++ libraries (vector, iostream, cmath, limits)",
    "time.h",
    "cstring",
    "iostream"
  ]
}