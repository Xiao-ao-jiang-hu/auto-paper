{
  "file_path": "VSR-LKH-3-Final/SRC/FindTour.c, VSR-LKH-3-Final/SRC/MakeKOptMove.c",
  "function_name": "FindTour, MakeKOptMove",
  "code_snippet": "\n\n# ==========================================\n# File: VSR-LKH-3-Final/SRC/FindTour.c\n# Function/Context: FindTour\n# ==========================================\n#include \"LKH.h\"\n#include <stdlib.h>\n\nstatic void SwapCandidateSets();\nstatic GainType OrdinalTourCost;\n\nGainType FindTour()\n{\n    GainType Cost;\n    Node *t;\n    int i;\n    double EntryTime = GetTime();\n    BestTime = 0;\n    t = FirstNode;\n    do\n        t->OldPred = t->OldSuc = t->NextBestSuc = t->BestSuc = 0;\n    while ((t = t->Suc) != FirstNode);\n    if (Run == 1 && Dimension == DimensionSaved) {\n        OrdinalTourCost = 0;\n        for (i = 1; i < Dimension; i++)\n            OrdinalTourCost += C(&NodeSet[i], &NodeSet[i + 1])\n                - NodeSet[i].Pi - NodeSet[i + 1].Pi;\n        OrdinalTourCost += C(&NodeSet[Dimension], &NodeSet[1])\n            - NodeSet[Dimension].Pi - NodeSet[1].Pi;\n        OrdinalTourCost /= Precision;\n    }\n    BetterCost = PLUS_INFINITY;\n    BetterPenalty = CurrentPenalty = PLUS_INFINITY;\n    if (MaxTrials > 0)\n        HashInitialize(HTable);\n    else {\n        Trial = 1;\n        ChooseInitialTour();\n        CurrentPenalty = PLUS_INFINITY;\n        CurrentPenalty = BetterPenalty = Penalty ? Penalty() : 0;\n    }\n    \n    \n    for (int i = 1; i <= Dim; i++) {\n        for (Candidate* CNN = NodeSet[i].CandidateSet; CNN->To; CNN++) {\n            CNN->Value = LB2 / ((double)(Distance_TRUE(&NodeSet[i], CNN->To) + CNN->Alpha));\n        }\n    }\n    \n    double badtime = GetTime();\n    for (Trial = 1; Trial <= MaxTrials; Trial++) {\n        \n        if (GetTime() - badtime >= TimeLimit / 20.0) {\n            Method = (Method) % 3 + 1;\n            badtime = GetTime();\n        }\n        GainMin = 0;\n        if (GetTime() - EntryTime >= TimeLimit) {\n            if (TraceLevel >= 1)\n                printff(\"*** Time limit exceeded ***\\n\");\n            break;\n        }\n        /* Choose FirstNode at random */\n        if (Dimension == DimensionSaved)\n            FirstNode = &NodeSet[1 + Random() % Dimension];\n        else\n            for (i = Random() % Dimension; i > 0; i--)\n                FirstNode = FirstNode->Suc;\n        ChooseInitialTour();\n        if ((ProblemType == SOP || ProblemType == M1_PDTSP) &&\n            (InitialTourAlgorithm != SOP_ALG || Trial > 1))\n            SOP_RepairTour();\n        Cost = LinKernighan();\n        \n        Node* From = FirstNode;\n        Candidate *NFrom, *NN, Temp;\n        do{\n            for (NFrom = From->CandidateSet; NFrom->To; NFrom++) {\n                Temp = *NFrom;\n                for (NN = NFrom - 1;\n                     NN >= From->CandidateSet &&\n                     (Temp.Value > NN->Value ||\n                      (Temp.Value == NN->Value && Temp.Alpha < NN->Alpha)); NN--)\n                    *(NN + 1) = *NN;\n                *(NN + 1) = Temp;\n            }\n        }\n        while((From = From->Suc) != FirstNode);\n        \n        if (FirstNode->BestSuc && !TSPTW_Makespan) {\n            /* Merge tour with current best tour */\n            t = FirstNode;\n            while ((t = t->Next = t->BestSuc) != FirstNode);\n            Cost = MergeWithTour();\n        }\n        if (Dimension == DimensionSaved && Cost >= OrdinalTourCost &&\n            BetterCost > OrdinalTourCost && !TSPTW_Makespan) {\n            /* Merge tour with ordinal tour */\n            for (i = 1; i < Dimension; i++)\n                NodeSet[i].Next = &NodeSet[i + 1];\n            NodeSet[Dimension].Next = &NodeSet[1];\n            Cost = MergeWithTour();\n        }\n        if (CurrentPenalty < BetterPenalty ||\n            (CurrentPenalty == BetterPenalty && Cost < BetterCost)) {\n            badtime = GetTime();\n            if (TraceLevel >= 1) {\n                printff(\"* %d: \", Trial);\n                StatusReport(Cost, EntryTime, \"\");\n            }\n            BetterCost = Cost;\n            BestTime = GetTime() - EntryTime;\n            BetterPenalty = CurrentPenalty;\n            RecordBetterTour();\n            if (BetterPenalty < BestPenalty ||\n                (BetterPenalty == BestPenalty && BetterCost < BestCost))\n                WriteTour(TourFileName, BetterTour, BetterCost);\n            AdjustCandidateSet();\n            HashInitialize(HTable);\n            HashInsert(HTable, Hash, Cost);\n        } else if (TraceLevel >= 2) {\n            printff(\"  %d: \", Trial);\n            StatusReport(Cost, EntryTime, \"\");\n        }\n        /* Record backbones if wanted */\n        if (Trial <= BackboneTrials && BackboneTrials < MaxTrials) {\n            SwapCandidateSets();\n            AdjustCandidateSet();\n            if (Trial == BackboneTrials) {\n                if (TraceLevel >= 1) {\n                    printff(\"# %d: Backbone candidates ->\\n\", Trial);\n                    CandidateReport();\n                }\n            } else\n                SwapCandidateSets();\n        }\n    }\n    if (BackboneTrials > 0 && BackboneTrials < MaxTrials) {\n        if (Trial > BackboneTrials ||\n            (Trial == BackboneTrials &&\n             (!StopAtOptimum || BetterCost != Optimum)))\n            SwapCandidateSets();\n        t = FirstNode;\n        do {\n            free(t->BackboneCandidateSet);\n            t->BackboneCandidateSet = 0;\n        } while ((t = t->Suc) != FirstNode);\n    }\n    t = FirstNode;\n    if (Norm == 0 || MaxTrials == 0) {\n        do\n            t = t->BestSuc = t->Suc;\n        while (t != FirstNode);\n    }\n    Hash = 0;\n    do {\n        (t->Suc = t->BestSuc)->Pred = t;\n        Hash ^= Rand[t->Id] * Rand[t->Suc->Id];\n    } while ((t = t->BestSuc) != FirstNode);\n    if (Trial > MaxTrials)\n        Trial = MaxTrials;\n    ResetCandidateSet();\n    CurrentPenalty = BetterPenalty;\n    return BetterCost;\n}\n\nstatic void SwapCandidateSets()\n{\n    Node *t = FirstNode;\n    do {\n        Candidate *Temp = t->CandidateSet;\n        t->CandidateSet = t->BackboneCandidateSet;\n        t->BackboneCandidateSet = Temp;\n    } while ((t = t->Suc) != FirstNode);\n}\n\n# ==========================================\n# File: VSR-LKH-3-Final/SRC/MakeKOptMove.c\n# Function/Context: MakeKOptMove\n# ==========================================\n#include \"Sequence.h\"\n#include \"Segment.h\"\n\n/*\n * The MakeKOptMove function makes a K-opt move (K >= 2) using sorting by \n * reversals.\n *   \n * Let t[1:2K] be the sequence of nodes used in the K-opt move.  \n * \n *    {(t[2i-1],t[2i]) | 1 <= i <= K} is the set of edges to be excluded \n *                                    from the tour. \n \n *    {(t[2i],t[incl[2i]]) | 1 <= i <= K} is the set of edges to be \n *                                        included in the tour.\n *   \n * And let p[1:2K] be a permutation corresponding to the sequence in which \n * the nodes occur on the tour.\n *   \n * Then the move corresponds to sorting p by reversals. \n *   \n * MakeKOptMove finds the minimum number of reversals and makes the \n * corresponding series of 2-opt moves (swaps).\n *   \n * The implementation is based upon the algorithm for sorting signed \n * permutations by reversals given in\n *   \n *    A, Bergeron,\n *    \"A Very Elementary Presentation of the Hannenhalli-Pevzner Theory\",\n *    Lecture Notes in Computer Science, 2089, 106-117 (2001). \n */\n\nstatic void Reverse(int i, int j);\nstatic int Score(int Left, int Right, int K);\n\nvoid MakeKOptMove(int K)\n{\n    int i, j, Best_i = 0, Best_j = 0, BestScore, s;\n\n    FindPermutation(K);\n  FindNextReversal:\n    /* Find the oriented reversal that has maximal score */\n    BestScore = -1;\n    for (i = 1; i <= 2 * K - 2; i++) {\n        j = q[incl[p[i]]];\n        if (j >= i + 2 && (i & 1) == (j & 1) &&\n            (s = i & 1 ? Score(i + 1, j, K) :\n             Score(i, j - 1, K)) > BestScore) {\n            BestScore = s;\n            Best_i = i;\n            Best_j = j;\n        }\n    }\n    if (BestScore >= 0) {\n        i = Best_i;\n        j = Best_j;\n        if (i & 1) {\n            Swap1(t[p[i + 1]], t[p[i]], t[p[j]]);\n            Reverse(i + 1, j);\n        } else {\n            Swap1(t[p[i - 1]], t[p[i]], t[p[j]]);\n            Reverse(i, j - 1);\n        }\n        goto FindNextReversal;\n    }\n    /* No more oriented reversals. Cut a simpe hurdle, if any.\n     * Note that there can be no super hurdles */\n    for (i = 1; i <= 2 * K - 3; i += 2) {\n        j = q[incl[p[i]]];\n        if (j >= i + 3) {\n            Swap1(t[p[i]], t[p[i + 1]], t[p[j]]);\n            Reverse(i + 1, j - 1);\n            goto FindNextReversal;\n        }\n    }\n}\n\n/*\n * The Reverse function reverses the sequence of elements in p[i:j].\n * The inverse permutation q is updated accordingly.\n */\n\nstatic void Reverse(int i, int j)\n{\n    for (; i < j; i++, j--) {\n        int pi = p[i];\n        q[p[i] = p[j]] = i;\n        q[p[j] = pi] = j;\n    }\n}\n\n/*\n * The Score function computes the score of a reversal. The score is the \n * number of oriented pairs in the resulting reversal.\n */\n\nstatic int Score(int Left, int Right, int K)\n{\n    int Count = 0, i, j;\n\n    Reverse(Left, Right);\n    for (i = 1; i <= 2 * K - 2; i++) {\n        j = q[incl[p[i]]];\n        if (j >= i + 2 && (i & 1) == (j & 1))\n            Count++;\n    }\n    Reverse(Left, Right);\n    return Count;\n}",
  "description": "Combined Analysis:\n- [VSR-LKH-3-Final/SRC/FindTour.c]: This file implements the main trial loop of the VSR-LKH algorithm, which corresponds to Step 5 in the algorithm description. Key implementations include: 1) Initialization of candidate set values using the α-measure (Step 2), 2) Dynamic switching between reinforcement strategies (Method cycling every TimeLimit/20.0 seconds, Step 4), 3) Multiple trials up to MaxTrials (Step 5), 4) Candidate set reordering based on Value and Alpha after each LinKernighan search (Step 5.d.iii), 5) Recording and updating best tours with AdjustCandidateSet (Step 5.f). However, the detailed ε-greedy selection and Q-value updates (Steps 5.d.iii-v) are implemented within LinKernighan() function, not directly visible here.\n- [VSR-LKH-3-Final/SRC/MakeKOptMove.c]: This file implements the core k-opt local search operation in the LKH algorithm, which is Step 5(d) in the VSR-LKH algorithm description. The MakeKOptMove function performs K-opt moves using sorting by reversals, which corresponds to the edge exchange operations in the TSP tour improvement phase. It implements the mathematical model's objective of minimizing tour length through edge swaps, though the actual distance calculations occur elsewhere. The code uses the Bergeron algorithm for sorting signed permutations by reversals to find optimal sequences of 2-opt moves that collectively form a K-opt move.",
  "dependencies": [
    "SOP_RepairTour",
    "Segment.h",
    "HashInitialize",
    "WriteTour",
    "MergeWithTour",
    "LinKernighan",
    "GetTime",
    "AdjustCandidateSet",
    "SwapCandidateSets",
    "ChooseInitialTour",
    "Swap1 (external function)",
    "FindPermutation (external function)",
    "StatusReport",
    "ResetCandidateSet",
    "CandidateReport",
    "stdlib.h",
    "Random",
    "RecordBetterTour",
    "Sequence.h",
    "HashInsert",
    "Global arrays: t, p, q, incl",
    "LKH.h",
    "printff"
  ]
}