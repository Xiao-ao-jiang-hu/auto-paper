{
  "file_path": "discs/models/mis.py",
  "function_name": "MIS",
  "code_snippet": "\n\n# ==========================================\n# File: discs/models/mis.py\n# Function/Context: MIS\n# ==========================================\n\"\"\"Max Independent Set model.\"\"\"\n\nfrom discs.models import comb_ebm\nimport jax.numpy as jnp\nimport ml_collections\n\n\nclass MIS(comb_ebm.BinaryNodeCombEBM):\n  \"\"\"Max Independent Set model.\"\"\"\n\n  def __init__(self, config: ml_collections.ConfigDict):\n    super().__init__(config)\n    self.config = config.model\n    self.max_num_nodes = self.config.max_num_nodes\n    self.penalty_coeff = self.config.get('penalty', 2.0)\n\n  def make_init_params(self, rng):\n    try:\n      data_list = next(self.datagen)\n    except:\n      return None\n    return data_list\n\n  def penalty(self, params, x):\n    x = x * params['mask']\n    edge_from = params['edge_from']\n    edge_to = params['edge_to']\n    edge_mask = params['edge_mask']\n\n    gather2src = x[:, edge_from]\n    gather2dst = x[:, edge_to]\n\n    violation = gather2src * gather2dst * edge_mask\n    penalty = self.penalty_coeff * jnp.sum(violation, axis=1)\n    return penalty\n\n  def objective(self, params, x):\n    _ = params\n    x = x * params['mask']\n    return jnp.sum(x, axis=1)\n\n  def logratio_in_neighborhood(self, params, x):\n    edge_from = params['bidir_edge_from']\n    edge_to = params['bidir_edge_to']\n\n    gather2dst = x[:, edge_to]\n    diff_penalty = self.penalty_coeff * gather2dst\n    diff_arr = jnp.zeros(x.shape, dtype=diff_penalty.dtype)\n    diff_arr = diff_arr.at[jnp.expand_dims(jnp.arange(x.shape[0]), axis=1),\n                           edge_from].add(diff_penalty)\n\n    sign = (1 - x * 2) * params['mask']\n    logratio = (sign - sign * diff_arr) / params['temperature']\n    logratio = logratio * params['mask'] + -1e9 * (1 - params['mask'])\n    return logratio, 1, self.get_neighbor_fn\n\n\ndef build_model(config):\n  return MIS(config)",
  "description": "Combined Analysis:\n- [discs/models/mis.py]: This file implements the Max Independent Set (MIS) combinatorial optimization problem as an energy-based model for discrete sampling. It directly encodes the mathematical model: objective = sum(x_i) (maximizing independent set size, equivalent to minimizing -sum(x_i)), with penalty = λ * sum(x_i*x_j) for adjacent nodes (i,j) ∈ E to enforce independence constraints. The penalty term corresponds to the constraint x_i x_j = 0 ∀ (i,j) ∈ E. The implementation provides energy calculations for MCMC sampling with simulated annealing (via temperature parameter) and supports locally balanced proposals through logratio_in_neighborhood. This matches the paper's description of converting combinatorial optimization to energy-based sampling with penalty terms.",
  "dependencies": [
    "BinaryNodeCombEBM base class",
    "jax.numpy",
    "mask parameter for variable selection",
    "ml_collections",
    "discs.models.comb_ebm",
    "datagen generator",
    "edge_from/edge_to graph parameters"
  ]
}